# 恢复控制

## 1 故障与恢复

### 1.1 事务故障

事务故障：事务的运行没有到达预期的终点就被终止

非预期故障：

- 不能由事务程序处理的
- 如运算溢出，发生死锁而被选中撤消该事务

可预期故障：

- 应用程序可以发现的事务故障，并且应用程序可以让事务回滚
- 如转帐时发现帐面金额不足

### 1.2 系统故障

软故障：在硬件故障、软件错误的影响下，虽引起内存信息丢失，但未破坏外存中数据

- 如CPU故障、突然停电；DBMS, OS, 应用程序等异常终止

### 1.3 介质故障

硬故障：又称磁盘故障，破坏外存上的数据库，并影响正在存取这部分数据的所有事务

- 如磁盘的磁头碰撞；瞬时的强磁场干扰

### 1.4 恢复

- 恢复是把数据库从错误状态恢复到某一正确状态的功能，从而确保数据库的一致性

- 恢复的基本原理是冗余，即数据库中任一部分的数据可以根据存储在系统别处的冗余数据来重建

- 冗余
  - 备份（数据）
  - 日志（事务活动）

## 2 备份

### 2.1 转储

生成备份的过程：转储

- 将数据库复制到磁带或另一个磁盘上保存起来的过程。

- 这些备用数据称为后备（后援）副本。

#### 2.1.1 转储类型

- 静态转储
  - 转储期间不允许对数据库进行任何存取、修改活动
  - **转储期间不向外提供服务**
- 动态转储
  - 转储期间允许对数据库进行存取或修改
  - **转储期间数据块还对外提供服务**
- 海量转储
  - 每次转储**全部数据库**
- 增量转储
  - 每次只转储上次转储后***更新过的数据**

### 2.2 SQL Server 数据库全量备份

- 完整的数据库备份
- 数据库备份创建备份完成时数据库内存在的数据的副本，通常按常规时间间隔调度
- 还原数据库备份将重新创建数据库和备份完成时数据库中存在的所有相关文件
  - 但是，自创建备份后所做的任何数据库修改都将丢失

```sql
USE master

EXEC sp_addumpdevice 'disk', 'MyBKDB', DISK ='c:\MyBKDB.dat'

BACKUP DATABASE LJCHEN TO MyBKDB

RESTORE DATABASE LJCHEN FROM MyBKDB
```

### 2.3 SQL Server 差异数据库备份

- 差异数据库备份（DCM）
- 差异数据库备份只记录自上次数据库备份后发生更改的数据，比数据库备份小而且速度快
- 使用差异数据库备份将数据库还原到差异数据库备份完成时的那一点
- 初始得是一个全量的备份
- 一个位图，每一个页一位，如果修改了则把这个页对应位图上的位置为 1
  - 增量备份的时候把修改过的备份出去即可

```sql
/* 全量备份 */
BACKUP DATABASE LJCHEN TO MyBKDB WITH INIT
/* 增量备份*/
BACKUP DATABASE LJCHEN TO MyBKDB WITH DIFFERENTIAL

RESTORE DATABASE LJCHEN FROM MyBKDB WITH NORECOVERY
RESTORE DATABASE LJCHEN FROM MyBKDB WITH FILE=2, RECOVERY

```

### 2.4 SQL Server 事务日志备份

- 事务日志是自上次备份事务日志后对数据库执行的所有事务的一系列记录，它可以将数据库恢复到特定的即时点或恢复到故障点

```sql
BACKUP DATABASE MyDB TO MyDB_1 WITH INIT

BACKUP LOG MyDB TO MyDB_log1

BACKUP LOG MyDB TO MyDB_log2 WITH NO_TRUNCATE

```

```
RESTORE DATABASE MyDB FROM MyDB_1 WITH NORECOVERY

RESTORE LOG MyDB FROM MyDB_log1 WITH NORECOVERY

RESTORE LOG MyDB FROM MyDB_log2 WITH RECOVERY
```

- WITH NORECOVERY：**重做所有日志记录**。不管有没有commit都重做。
- WITH RECOVERY：**回滚失败事务日志记录**。如果有没有commit的事务，就把它回滚掉。
- 对结尾日志要用`RECOVERY`，对其他日志要用`NORECOVERY`

### 2.5 SQL Server 恢复模型

- 我们期望能够保留下来的工作越多，也就是希望数据库能够恢复到更近的一致性的状态
  - 这与数据库系统平时付出的代价相关

#### 2.5.1 简单恢复

- 允许将数据库恢复到最新的备份
  - 简单数据库备份，没有日志，只能恢复到最新的数据库备份那一刻的内容
- 数据库备份 + 差异备份（可选）

#### 2.5.2 完全恢复

- 允许将数据库恢复到故障点状态
  - 完全恢复（恢复到尽可能近的状态），先通过数据库备份恢复，然后通过日志记录恢复
- 数据库备份 + 差异备份（可选） + 事务日志备份

#### 2.5.3 大容量日志记录恢复（BCM）

- 允许大容量日志记录操作（select into，bcp，bulk insert）
  - 批量的修改会导致日志文件庞大，对性能造成影响
  - 这种模式下，日志文件中只记录操作本身，操作所影响的数据写到其他的数据文件中
  - BCM 位图实现，把影响的页面单独写出去，并在位图上做标记
- 数据库备份 + 差异备份（可选） + 事务日志备份

#### 2.5.4 切换恢复模型

- 可以将数据库从一个恢复模型切换到另一个恢复模型，以满足不断变化的业务要求
- 例如，如果系统需要完全的可恢复性，可以在装载和索引操作的过程中，将数据库的恢复模型更改到批量日志记录模型，然后再返回到完全恢复

### 2.6 MySQL 备份类型

- 备份内容
  - 逻辑备份：从表的角度备份
  - 裸文件备份：把磁盘上面的数据文件备份出去
- 备份方法
  - 热备(Hot Backup)：数据库保持业务工作的同时进行备份
  - 冷备(Cold Backup)：数据库停下来备份
  - 温备(Warm Backup)：只允许读操作下执行，不允许写操作执行
- 备份数据库内容
  - 完全备份
  - 增量备份
  - 日志备份

## 日志

- 日志文件是以事务为单位用来记录数据库的每一次更新活动的文件，由系统自动记录
  - 增删改，不记录查询
- 日志内容包括
  - 记录名、旧记录值、新记录值、事务标识符、操作标识符等
- 内容如下
  - 事务$T_i$ 开始时，写入日志：$T_istart$
  - 事务$T_i$执行 write(X) 前，写入日志：<$T_i$,X,V1,V2>
    - V1 是 X 更新前的值，V2 是 X 更新后的值
  - 事务 $T_i$ 结束后，写入日志：$T_icommit$
- 日志记录的是值的变换，而不是逻辑的操作
  - 记录的是物理值的话，不管重复多少次，结果中是一致的
  - 如果记录具体的逻辑操作，重复多次的结果不一样
    - 例如一个操作是-10，重复多次则会多次-10

### 事务分类

- 基于日志记录对事务进行分类
- 圆满事务（成功了）
  - 日志文件中记录了事务的 commit 标识
- 夭折事务（失败的）
  - 日志文件中只有事务的 begin transaction 标识，无 commit

### 基本的恢复操作

- 对圆满事务所做过的修改应执行 redo 操作，即重新执行该操作，修改对象被赋予

  新记录值

  - 不管 redo 多少次，结果都是一样的

- 对夭折事务所做过的修改应执行undo操作，即撤消该操作，修改对象被赋予

  旧记录值

  - 不管undo多少次，结果都是一样的

### 事务的原语操作

- input(X)：将包含数据库元素 X 的**磁盘块**拷贝到**内存缓冲区**
- read(X,t)：将**内存缓冲区**的数据库元素 X 拷贝到事务的**局部变量** t
- write(X,t)：将**局部变量** t 的值拷贝到**内存缓冲区**中的数据库元素 X
- output(X)：将包含 X 的**缓冲区**拷贝回**磁盘**
- 发出者不同
  - read 和 write 由**事务**发出
  - input 和 output 由**缓冲区管理器**（或**日志管理器**）发出

### 先写日志的原则(WAL)

- 保证原子性
- 日志记录将要发生何种修改
- 写入 DB 表示实际发生何种修改

- Write Ahead Log（WAL）
  - 对于尚未提交的事务，在将DB缓冲区写到外存之前，必须先将日志缓冲区内容写到外存去

- 如果先写 DB，则可能在写的中途发生系统崩溃，导致内存缓冲区内容丢失，而外存 DB 处于不一致状态，由于日志缓冲区内容已破坏，导致无法对 DB 恢复
- 如果先写数据库再写日志记录的话
  - 假设这样的一种情况，日志记录还没写完，系统崩溃了
  - 此时日志中只有 A 的记录
  - 故障恢复的时候，由于缺少 commit，认为是夭折事务，执行 undo
  - 此时 B 的结果没有修改回去，造成错误（不一致）